function [outdata, tbase, out_rate, err] = burst(sfile)
% BUrst: Method to generate pulse train waveforms with a repeat (Burst).
% Usage
%     Not normally called directly by the user

% PULSEGEN - create pulse train waveform
%
%    PULSEGEN produces a pulse train waveform pulse_out
%    specified by the parameters in the structure sfile.
%
%    The stimulus structure is generated by new.m.
%		The following parameters are required:
%   sfile.NBursts = number of repeats of the bursts
%   sfile.IBI = interburst interval
%   sfile.Npulses= number of pulses in the train
%   sfile.Delay= delay to first pulse
%   sfile.IPI= interpulse interval (one number)
%   sfile.Duration = duration list for pulses (compound pulses allowed at each interval)
%   sfile.Level= level list for pulses (compound levels corresponding to durations)
%   sfile.LevelFlag= 'absolute' or 'relative': levels after first are either absolute or relative
%   sfile.Scale= scale factor applied to output
%	 sfile.Offset = offset added to output (after scaling)
%   sfile.Sequence= sequence (operates as in steps - multiple seqeuences allowed)
%   sfile.SeqParList= parameters to sequence (apply according to entries in sequence)
%   sfile.SeqStepList= which step to be operated on by the sequence element if level or duration
%
%
% original by S.C. Molitor, 8/2000
% modified Paul B. Manis, Ph.D.
% pmanis@med.unc.edu
% 9/1/2000   uses new record_parse and step generator
%

% initialize output
outdata = {};
err = 0;
tbase = {};
out_rate = [];

% check input
if(isempty(sfile))
    QueMessage('pulse: No STIM?', 1);
    return;
end;

% perform parameter checking - are duration and level lists matched?
if(length(sfile.Duration.v) ~= length(sfile.Level.v))
    QueMessage(sprintf('pulse: in %s, unmatched # dur and levels ', sfile.Name.v), 1);
    return;
    %   ns = min([length(sfile.Duration.v) length(sfile.Level.v)]); % ns is number of steps in protocol
else
    ns = length(sfile.Duration.v); % use either they are the same
end;

% compute the sequences
vlist=seq_parse(sfile.Sequence.v); % partition list. Result is cell array, fastest first.
if(isempty(vlist))
    err = 1;
    return;
end;

nvl = size(vlist, 2); % number of vlist elements
nout = length(vlist{1}); % length of protocol

% copy sequence parameter into cell array
s = lower(sfile.SeqParList.v); % get the parameter to sequence
pars={}; % pars holds the parameters sequenced
i = 1;
while(~isempty(s))
    [pars{i}, s] = strtok(s, ' '); % get the tokens into a cell array
    i = i + 1;
end;

% verify valid sequence parameter for this stimulus type
for i = 1:length(pars)
    if(~strmatch(pars{i}, {'level','duration', 'ipi'}))
        fprintf('pulse: Sequencing only allowed on level, duration, and ipi\n');
        err = 1;
        return;
    end;
end;

% get pulse number and check to see if its valid
parn = sfile.SeqStepList.v; % and the pulse element number to operate on
if(any(parn > ns) || any(parn < 1))
    fprintf('pulse: Attempt to sequence invalid step #\n');
    err = 1;
    return;
end;


% at this point, the basic parameters appear to be valid.
% compute some base values

out_rate=(1000000/sfile.Sample_Rate.v); % convert to samples per second (rate in usec)
% note factor of 2 is to allow for using the second channel simultaneously...

base_dur = sfile.Duration.v; % get basic duration list
base_lev = sfile.Level.v; % get basic level list
base_ipi = sfile.IPI.v; % base IPI list
nrate = sfile.Sample_Rate.v; % sample rate, in microseconds (note divisions below!)
NSR = nrate/1000;
% if we are sequencing durations, the the stimulus duration must accomodate the longest we must make
% find out and substitute it to get the total duration
du = strmatch('duration', pars); % for duration sequences
if(~isempty(du))
    base_dur(parn(du)) = max(vlist{parn(du)});
end;

if(any(base_dur < NSR))
    k = find(base_dur > 0);
    nrate = min(base_dur(k))*1000;
    NSR = nrate/1000;
end;

% if we are sequencing IPIs, the get information
ipi = strmatch('ipi', pars); % for ipi sequences
if(~isempty(ipi))
    base_ipi(parn(ipi)) = max(vlist{parn(ipi)});
end;
if(any(base_ipi < NSR)) % check rate
    k = find(base_ipi > 0);
    nrate = min(base_ipi(k))*1000;
    NSR = nrate/1000;
end;

% get levels sequenced
base_level = sfile.Level.v;
le = strmatch('level', pars); % gets which one is the level
if(~isempty(le))
    base_level(parn(le)) = min(vlist{parn(le)});
end;
NB = sfile.NBurst.v; % get the number of bursts and the interburst interval here.
IBI = floor(sfile.IBI.v/NSR)*NSR; % fix on sample rate

% total duration of longest stimulus
tot_dur = sfile.Delay.v + (sfile.Npulses.v+1)*(max(base_ipi)+sum(base_dur)); % (dur is in msec).
if(NB > 1)
    tot_dur = (NB-1)*IBI+tot_dur;
end;
npts = floor(0.5+tot_dur/(NSR));  % points in the array


% check the level flag.
if (strcmpi(sfile.LevelFlag.v, 'relative'))
    relflag = 1;
elseif (strcmpi(sfile.LevelFlag.v, 'absolute'))
    relflag = 0; % means nothing - just a place holder
else % error
    QueMessage('pulse: LevelFlag must be ''relative'' or ''absolute''\n', 1);
    return
end
%fprintf(1, 'Level flag is: %d (0 - absolute, 1 = relative)\n', relflag);

outdata = cell(nout, 1);
tbase = cell(nout, 1);

% generate ONE waveform for scope mode
outdata{1}.vsco=zeros(1,npts);
tbase{1}.vsco=nrate*(0:npts-1)/1000; % time base, in msec for the output

bipi = floor(base_ipi/NSR)*NSR;
sdel = floor(sfile.Delay.v/NSR)*NSR;

if(length(base_ipi) > 1) % compute step start times, according to npulses and ipi
    pulse_begin = sdel + (0 : sfile.Npulses.v - 1) * bipi(1);
else
    pulse_begin = sdel + (0 : sfile.Npulses.v - 1) * bipi;
end;

sdur = floor(sfile.Duration.v/NSR);

for m = 1:nout % for each element of the sequence
    outdata{m}.v=zeros(1,npts);
end;
for nbn = 1:NB % for each burst we need to present
    bn0k = 1 + floor((nbn-1)*IBI/(NSR));
    for n = 1 : length(pulse_begin) % for each pulse in the train
        k = bn0k + floor(pulse_begin(n)/(NSR)); % get the index of start of pulse
        for i=1:ns % each pulse consists of a series of steps, so create steps
            j = sdur(i)-1; % Number of points in the duration step dur in msec; convert rate to msec too
            if(relflag && i > 1) % check relative
                outdata{1}.v(k:k+j) = sfile.Level.v(1)*sfile.Level.v(i); % value is constant for that time
            else
                outdata{1}.v(k:k+j) = sfile.Level.v(i);
            end;
            k = k + j+1;
        end;
    end
    outdata{1}.vsco = outdata{1}.vsco*sfile.Scale.v + sfile.Holding.v; % scale and offset the data

    % create pulsetrain template from levels & durations

    for m = 1:nout % for each element of the sequence
        if(~isempty(ipi)) % compute step start times, according to npulses and ipi
            vipi = floor(vlist{ipi}(m)/nrate)*nrate;
            pulse_begin = sdel + (0 : sfile.Npulses.v  - 1) * vipi;
        else
            pulse_begin = sdel + (0 : sfile.Npulses.v - 1) * bipi; % single pulse.
        end;

        for n = 1 : length(pulse_begin) % for each pulse in the train
            k = floor(pulse_begin(n)/(NSR))+1; % get the index of start of pulse
            for i=1:ns % each pulse consists of a series of steps, so create steps
                j = 0;
                if(isempty(du))% ? no changes in duration
                    j = sdur(i)-1; % Number of points in the duration step dur in msec; convert rate to msec too
                else
                    if(i == parn(du)) % are we altering duration on this pulse component?
                        j = floor(vlist{du}(m)/(NSR))-1;   % yes, set from sequence list
                    else
                        j = sdur(i)-1; % no, just set from input. Number of points in the duration step dur in msec; convert rate to msec too
                    end;
                end;
                if(isempty(le)) % level setup
                    if(relflag && i > 1) % check relative
                        outdata{m}.v(k:k+j) = sfile.Level.v(1)*sfile.Level.v(i); % adjust subsequent levels relative to first level
                    else
                        outdata{m}.v(k:k+j) = sfile.Level.v(i); % otherwise just use the values
                    end;
                else
                    if(find(i == parn(le))) % check if we are sequencing levels
                        ii = find(i == parn(le)); % find out which sequence corresponds
                        if(relflag && i > 1) % check relative if sequencing
                            outdata{m}.v(k:k+j) = sfile.Level.v(1)*vlist{le(ii)}(m); % relative scaling
                        else
                            outdata{m}.v(k:k+j) = vlist{le(ii)}(m); % copy it over
                        end;
                    else
                        if(relflag && i > 1) % check relative if not sequencing
                            outdata{m}.v(k:k+j) = sfile.Level.v(1)*sfile.Level.v(i); % value is constant for that time
                        else
                            outdata{m}.v(k:k+j) = sfile.Level.v(i);
                        end;
                    end;
                end;
                k = k + j+1;
            end;
        end
        tbase{m}.v=nrate*(0:npts-1)/1000; % time base, in msec for the output
    end; % done with generating the pulse train waveform set
end; % done with generating the bursts (n bursts)
for m = 1:nout % for each element of the sequence
    outdata{m}.v = outdata{m}.v*sfile.Scale.v + sfile.Holding.v; % scale and offset the data
end;
outdata{1}.vsco=outdata{1}.v; % make the same !!!! %%%% kludge.

%check for superposition, and do it if necessary
if(~isempty(sfile.Superimpose.v))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'superimpose');
    if(err)
        return;
    end;
end;
% and the second channel information
if(~isempty(unblank(sfile.Addchannel.v)))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'addchannel');
    if(err)
        return;
    end;
end;

err = 0; % only clear error flag if we make it all the way through.

return
