function [outdata, tbase, out_rate, err] = poisson(sfile)
% pulse: Method to generate poisson pulse train waveforms
% Usage
%     Not normally called directly by the user

% poisson - create poisson pulse train waveform
%
%    poisson produces a pulse train waveform pulse_out with
%    poisson-distributed event intervals
%    specified by the parameters in the structure sfile.
%
%    The stimulus structure is generated by new.m.
%		The following parameters are required:
%     case 'poisson' % create a poisson stimulus train (specify mean interval, dead time).
%         sfile.Sample_Rate = create_element(20, SGL, 7, 'Rate(us)', '%6.1f', 0, 1); % base clock rate for stimulus, in microseconds.
%         sfile.Spont=create_element('high', SGL, 8, 'SpontClass', '%c');
%         sfile.Rate=create_element(8.0, SGL, 9, 'Mean Rate (Hz)', '%9.4f', 0, 0.1, 5000.0);
%         sfile.Deadtime=create_element(60.0, SGL, 10, 'Deadtime (ms)', '%8.1f', 0, 0.0, 20.0);
%         sfile.Delay=create_element(500, SGL, 11, 'Delay(ms)', '%8.2f', 0, 0, 5000.0);
%         sfile.Duration=create_element(100, SGL, 12, 'Duration(ms)', '%8.2f', 0, 1, 10000.0); % interim holding value
%         sfile.Alpha=create_element(0, SGL, 14, 'Tau(ms)', '%8.3f', 0, -1000., 1000);
%         sfile.Amplitude=create_element(1, SGL, 15, 'Amplitude(nA)', '%8.3f', 0, -10000., 10000);
%         sfile.Converge=create_element(1, SGL, 16, 'Convergence(N)', '%d', 0, 1, 100);
%         sfile.Sequence=create_element('20,50,100', SGL, 19, 'Sequence', '%c');
%         sfile.SeqParList=create_element('Rate', MULT, 20, 'SeqParameter', '%c');
%         sfile.seed
%
%
% original by S.C. Molitor, 8/2000
% modified Paul B. Manis, Ph.D.
% pmanis@med.unc.edu
% 9/1/2000   uses new record_parse and step generator
%

% initialize output
outdata = {};
err = 0;
tbase = {};
out_rate = [];

if(nargin == 0)
    % generate a fake test file...

    s = new('poisson');
    sfile = s; % just get the first channel...
    sfile.Sequence.v = '1;100';
    sfile.SeqParList.v = 'seed';
    sfile.Delay.v = 100;
end;
% check input
if(isempty(sfile))
    QueMessage('poisson: No STIM?', 1);
    return;
end;

% check the level flag first - it must be valid before we go forward
if (strcmpi(sfile.LevelFlag.v, 'relative'))
    relflag = 1;
elseif (strcmpi(sfile.LevelFlag.v, 'absolute'))
    relflag = 0; % means nothing - just a place holder
else % error
    QueMessage('poisson: LevelFlag must be ''relative'' or ''absolute''\n', 1);
    return
end

% define the potential variables that can be sequenced and confirm that
% args are ok
possible_sequences = {'Rate', 'Amplitude', 'Seed'};
ratepos = 1;
levpos = 2;
seedpos = 3;

if(chklength(sfile, possible_sequences, ones(length(possible_sequences), 1)))  % make sure incoming arguments are acceptable
    return;
end;

% find out which ones are sequenced
[seqflags, errp] = chkpars(sfile.SeqParList.v, possible_sequences); % check the parameters to be sequenced to be sure they are valid also
if(errp)
    return;
end;

% compute the sequences
if(~strcmp(unblank(sfile.Sequence.v), '') && ~isempty(sfile.Sequence.v))
    [vlist, nlist]=seq_parse(sfile.Sequence.v); % partition list. Result is cell array, fastest first.
    if(isempty(vlist))
        err = 1;
        return;
    end;
else
    vlist{1}= 0;
end;
nout = prod(nlist); % number of vlist elementsnout = length(vlist{1}); % length of protocol

% seqsteps = eval('sfile.SeqStepList.v');
seqparlist = textscan(sfile.SeqParList.v, '%s');
seqmatrix = zeros(length(possible_sequences), length(nlist));

for i = 1:length(seqparlist) %
    which = strcmpi(seqparlist{1}(i), possible_sequences);
    k = find(which == 1);
    seqmatrix(k,i) = i; %#ok<FNDSB> % store order in the proper location
end


% at this point, the basic parameters appear to be valid.
% compute some base values

out_rate=(1000000/sfile.Sample_Rate.v); % convert to samples per second (rate in usec)
% note factor of 2 is to allow for using the second channel simultaneously...

base_dur = sfile.StimDur.v; % get basic duration list
base_lev = sfile.Amplitude.v; % get basic level list
base_rate = sfile.Rate.v; % base IPI list
nrate = sfile.Sample_Rate.v; % sample rate, in microseconds (note divisions below!)

% total duration of longest stimulus
tot_dur = sfile.Delay.v + sum(sfile.StimDur.v); % (dur is in msec).

npts = floor(0.5+tot_dur/(nrate/1000));  % points in the array

if(sfile.Seed.v >= 0)
    rand('twister', sfile.Seed.v)
end;

outdata = cell(nout, 1);
tbase = cell(nout, 1);

% generate ONE waveform for scope mode
outdata{1}.vsco=zeros(1,npts);
pulse_begin = makepulses(sfile);

for n = 1 : length(pulse_begin) % for each pulse in the train
    k = floor(pulse_begin(n)/(nrate/1000))+1; % get the index of start of pulse
    for i=1:length(sfile.Duration.v) % each pulse consists of a series of steps, so create steps
        j = 0;
        j = floor(sfile.Duration.v(i)/(nrate/1000))-1; % Number of points in the duration step dur in msec; convert rate to msec too
        if(relflag && i > 1) % check relative
            outdata{1}.vsco(k:k+j) = sfile.Amplitude.v(1)*sfile.Amplitude.v(i); % value is constant for that time
        else
            outdata{1}.vsco(k:k+j) = sfile.Amplitude.v(i);
        end;        k = k + j;
    end;
end
outdata{1}.vsco(k+1:k+2) = 0;

outdata{1}.vsco = outdata{1}.vsco*sfile.Scale.v + sfile.Holding.v; % scale and offset the data
tbase{1}.vsco=nrate*(0:length(outdata{1}.vsco)-1)/1000; % time base, in msec for the output

% create pulsetrain template from levels & durations


for m = 1:nout % for each element of the sequence
    outdata{m}.v=zeros(1,npts);

    pulse_begin=makepulses(sfile);
    for i = 1 : length(pulse_begin) % for each pulse in the train
        lev = sfile.Amplitude.v(1); % get default level
        dur = sfile.Duration.v(1); % and duration
        k = floor(pulse_begin(i)/(nrate/1000)); % get index for duration
        j = floor(dur/(nrate/1000));
        if(relflag && i > 1) % if relative, make relative
            lev = sfile.amplitude.v(1)*lev;
        end;
        % first, is this step variable at all?
        if(~any(seqmatrix(:,levpos)))
            outdata{m}.v(k:k+j) = lev; % value is constant for that time
        else  % a parameter is sequencing on this step
            %             if(seqmatrix(durpos, i)) % duration is being sequenced
            %                 j = floor(vlist{seqmatrix(durpos, i)}(m)/nrate);
            %                 outdata{m}.v(k:k+j) = lev; % value is constant for that time
            %             end;            % note that if both are sequenced, order is important!
            if(seqmatrix(levpos, i)) % level is being sequenced for this step
                if(relflag && i > 1)
                    outdata{m}.v(k:k+j) = lev*vlist{seqmatrix(levpos, i)}(m);
                else
                    outdata{m}.v(k:k+j) = vlist{seqmatrix(levpos, i)}(m);
                end;
            end;
        end;
    end

    outdata{m}.v(k+1:k+2) = 0;
    outdata{m}.v = outdata{m}.v*sfile.Scale.v + sfile.Holding.v; % scale and offset the data
    tbase{m}.v=nrate*(0:length(outdata{m}.v)-1)/1000; % time base, in msec for the output
end; % done with generating the pulse train waveform set

%check for superposition, and do it if necessary
if(~isempty(sfile.Superimpose.v))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'superimpose');
    if(err)
        return;
    end;
end;
% and the second channel information
if(~isempty(unblank(sfile.Addchannel.v)))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'addchannel');
    if(err)
        return;
    end;
end;

%------------PLOT RESULT in Figure if we are in "test" mode....
if(nargin == 0)
    teststimplot(tbase, outdata, 1);
end;
err = 0; % only clear error flag if we make it all the way through.

return

function [pulse_begin] = makepulses(sfile) %#ok<INUSD>
pulse_begin = [];
delay = eval('sfile.Delay.v');
spont = eval('sfile.Spont.v');
rate = eval('sfile.Rate.v');
deadtime = eval('sfile.Deadtime.v');
stimdur = eval('sfile.StimDur.v');
totaldur = stimdur + delay;
tlast = 0;
i = 0;
while(tlast < totaldur) % fill the time
    if(tlast < delay)
        if(spont > 0)
            pb = 1000*randraw('exp', spont, 1); % select a spont interval...
 %           pb2 = 1000*randraw('exp', spont, 1);
            tproposed = pb + tlast;
            if(tproposed < delay && pb > deadtime) % only select if it falls in the current window
                i = i + 1;
                pulse_begin(i) = tproposed;
                tlast = tproposed;
            else
                tlast = delay; % interval would have been after start, so skip to next section
            end;
        else
            tlast = delay; % spont is 0, so don't even try
        end;
    else
        % now draw driven rate
        pb = 1000*randraw('exp', rate, 1);
        tproposed = pb + tlast;
        if(tproposed > totaldur) % 8t next pulse would be oustide interval.
            tlast = tproposed; % then we are done
        else
            if(pb > deadtime) % only select it if it is longer than deadtime
                i = i + 1;
                pulse_begin(i) = tproposed; %#ok<AGROW>
                tlast = tproposed;
            end;
        end
    end;
end;

return;

