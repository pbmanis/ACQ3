function [outdata, tbase, out_rate, err, sfile] = pulse(varargin)
% pulse: Method to generate pulse train waveforms
% Usage
%     Not normally called directly by the user

% PULSEGEN - create pulse train waveform
%
%    PULSEGEN produces a pulse train waveform pulse_out
%    specified by the parameters in the structure sfile.
%
%    The stimulus structure is generated by new.m.
%		The following parameters are required:
%   sfile.Npulses= number of pulses in the train
%   sfile.Delay= delay to first pulse
%   sfile.IPI= interpulse interval (one number)
%   sfile.Duration = duration list for pulses (compound pulses allowed at each interval)
%   sfile.Level= level list for pulses (compound levels corresponding to durations)
%   sfile.LevelFlag= 'absolute' or 'relative': levels after first are either absolute or relative
%   sfile.Scale= scale factor applied to output
%	 sfile.Offset = offset added to output (after scaling)
%   sfile.Sequence= sequence (operates as in steps - multiple seqeuences allowed)
%   sfile.SeqParList= parameters to sequence (apply according to entries in sequence)
%   sfile.SeqStepList= which step to be operated on by the sequence element if level or duration
%
%
% original by S.C. Molitor, 8/2000
% modified Paul B. Manis, Ph.D.
% pmanis@med.unc.edu
% 9/1/2000   uses new record_parse and step generator
%
% Revised 4/10/2008 to use new methods.
% - call with no arguments tests the algorithm.
% - uses state matrix to drive sequencing.

% initialize output
outdata = {};
err = 0;
tbase = {};
out_rate = [];

plotflag = 0;

if(nargin == 0) % test mode...
    sfile = new('pulse');
    plotflag = 1;
else
    sfile = varargin{1};
    if(isempty(sfile))
        QueMessage('pulse: No STIM?', 1);
        err = 1;
        return;
    end;
end;
if(~strcmpi(sfile.Method.v, {'pulse', 'SAM', 'testpulse'}))
    QueMessage(sprintf('pulse: loaded sfile is of type %s, not ours!', sfile.Method.v), 1);
    err = 1;
    return;
end;
if nargin == 2 && (strcmp(varargin{2}, 'plot') || varargin{2} == 1)
    plotflag = 1;
end;

% define the potential variables that can be sequenced and confirm that
% args are ok
possible_sequences = {'level', 'duration', 'ipi'};
levpos = 1; %#ok<*NASGU>
durpos = 2;
ipipos = 3;

if(chklength(sfile, possible_sequences, ones(length(possible_sequences), 1)))  % make sure incoming arguments are acceptable
    return;
end;
% check the parameters to be sequenced to be sure they are valid also
% seqflags is an nxm array of 0's and 1's
% iterating each row tells you which sequence parameter is being run (by
% column entry)
% successive rows are nested sequences.
% first index is row, second is column.
[seqflags, errp] = chkpars(sfile.SeqParList.v, possible_sequences);
if(errp)
    return;
end;
% compute the sequences
thisseq = strrep(sfile.Sequence.v, ' ', '');
if(~isempty(thisseq))
    [vlist, nlist]=acq_seq_parse(thisseq); % partition list. Result is cell array, fastest first.
    if(isempty(vlist))
        err = 1;
        return;
    end;
else
    vlist{1}= 0;
end;
nout = prod(nlist);


if strcmpi(sfile.Method.v, 'testpulse')
    % define the potential variables that can be sequenced in the TEST pulse and confirm that
    % args are ok
    possible_sequences2 = {'testlevel', 'testipi', 'testdelay'};
    levpos2 = 1;
    ipipos2 = 2;
    delpos2 = 3;
    
    if(chklength(sfile, possible_sequences2, ones(length(possible_sequences2), 1)))  % make sure incoming arguments are acceptable
        return;
    end;
    % check the parameters to be sequenced to be sure they are valid also
    % seqflags is an nxm array of 0's and 1's
    % iterating each row tells you which sequence parameter is being run (by
    % column entry)
    % successive rows are nested sequences.
    % first index is row, second is column.
    [seqflags2, errp] = chkpars(sfile.TestSeqParList.v, possible_sequences2);
    if(errp)
        return;
    end;
    % compute the sequences
    thisseq2 = strrep(sfile.TestSequence.v, ' ', '');
    if(~isempty(thisseq2))
        [vlist2, nlist2]=acq_seq_parse(thisseq2); % partition list. Result is cell array, fastest first.
        if(isempty(vlist2))
            err = 1;
            return;
        end;
    else
        vlist2{1}= 0;
    end;
nout2 = prod(nlist2);
end


% at this point, the basic parameters appear to be valid.
% compute some base values

out_rate=(1000000/eval('sfile.Sample_Rate.v')); % convert to samples per second (rate in usec)
% note factor of 2 is to allow for using the second channel simultaneously...

base_dur = eval('sfile.Duration.v'); % get basic duration list
base_lev = eval('sfile.Level.v'); % get basic level list
base_ipi = eval('sfile.IPI.v'); % base IPI list
nrate = eval('sfile.Sample_Rate.v'); % sample rate, in microseconds (note divisions below!)
if strcmpi(sfile.Method.v, 'testpulse')
    base_dur2 = eval('sfile.TestDuration.v');
    base_lev2 = eval('sfile.TestLevel.v');
    base_ipi2 = eval('sfile.TestIPI.v');
    base_del2 = eval('sfile.TestDelay.v');
end;

fnrate = nrate/1000.;
% total duration of longest stimulus
tot_dur = sfile.Delay.v + (sfile.Npulses.v)*(max(base_ipi)+sum(base_dur)); % (dur is in msec).

last_pstart = sfile.Delay.v + ((sfile.Npulses.v-1)*max(base_ipi));

if strcmpi(sfile.Method.v, 'testpulse')
    testdelay = base_del2(1);
    if testdelay < last_pstart % if delay is too small, it might be relative to the end of the current train
        testdelay = last_pstart;
    end;
    tot_dur = testdelay + base_del2(1) + (sfile.TestNpulses.v+1)*(max(base_ipi2)+sum(base_dur2));
end;
npts = floor(0.5+tot_dur/fnrate);  % points in the array


% check the level flag.
if (strcmpi(sfile.LevelFlag.v, 'relative'))
    relflag = 1;
elseif (strcmpi(sfile.LevelFlag.v, 'absolute'))
    relflag = 0; % means nothing - just a place holder
else % error
    QueMessage('pulse: LevelFlag must be ''relative'' or ''absolute''\n', 1);
    return
end

outdata = cell(nout, 1);
tbase = cell(nout, 1);

% generate ONE waveform for scope mode
outdata{1}.vsco=zeros(1,npts);
tbase{1}.vsco=nrate*(0:npts-1)/1000; % time base, in msec for the output
sdel = floor(sfile.Delay.v/fnrate)*fnrate;

if(length(base_ipi) > 1) % compute step start times, according to npulses and ipi
    bipi = floor(base_ipi(1)/fnrate)*fnrate;
else
    bipi = floor(base_ipi/fnrate)*fnrate;
end;
pulse_begin = sdel + (0 : sfile.Npulses.v - 1) * bipi;

ifirst = floor(pulse_begin(1)/fnrate) + 1;

lev=pulseTrainGenerate(sfile.Npulses.v, bipi, sfile.Duration.v, sfile.Level.v, relflag, fnrate);
outdata{1}.vsco(ifirst:ifirst+length(lev)-1) = lev;
lastpt = find(lev > 0, 1, 'last');

if strcmpi(sfile.Method.v, 'testpulse')
    testdelays = floor(((lastpt-1) - sum(sfile.Duration.v)/fnrate))*fnrate;
    testdelays = testdelays + base_del2(1);
    lev2 = pulseTrainGenerate(sfile.TestNpulses.v, sfile.TestIPI.v, ...
        sfile.TestDuration.v, sfile.TestLevel.v, relflag, fnrate); % form individual pulses
    k = floor(testdelays/fnrate)+ifirst;
    outdata{1}.vsco(k:k+length(lev2)-1) = lev2;
end
outdata{1}.vsco = outdata{1}.vsco * sfile.Scale.v + sfile.Holding.v; % scale and offset the data
mm = 1;
for m = 1:nout % for each element of the sequence
    % mipi = mod(m, ipipos);
    
    % build pulse train template
    if(any(seqflags(:, ipipos))) % compute step start times, according to npulses and ipi
        pulse_begin = sdel + (0 : sfile.Npulses.v  - 1) * vlist{seqflags(:,ipipos) > 0}(m);
    else
        pulse_begin = sdel + (0 : sfile.Npulses.v - 1) * bipi; % single pulse.
    end;
    
    if any(seqflags(:, ipipos))
        ipi = vlist{seqflags(:,ipipos) > 0}(m);
    else
        ipi = sfile.IPI.v;
    end;
    levls = pulseTrainGenerate(sfile.Npulses.v, ipi, sfile.Duration.v, ...
        sfile.Level.v, relflag, fnrate);
    lastpt = find(levls > 0, 1, 'last');
    km = floor(pulse_begin(1)/fnrate)+1; % index to the first point in the array
    % add test pulses if required.
    % build pulse train template
    if strcmpi(sfile.Method.v, 'testpulse')
        testdelay = floor(((lastpt-1) - floor(sum(sfile.Duration.v)/fnrate))*fnrate);
        testdelay = testdelay + base_del2(1);
        for n = 1:nout2
            if(any(seqflags(:, delpos2))) % compute step start times, according to the delay timing
                pulse_begin2 = testdelay + (0 : sfile.TestNpulses.v  - 1) * vlist2{seqflags(:,delpos2) > 0}(n);
            else
                pulse_begin2 = testdelay + (0 : sfile.TestNpulses.v - 1) * bipi; % single pulse.
            end;
            levls2 = pulseTrainGenerate(sfile.TestNpulses.v, sfile.TestIPI.v, sfile.TestDuration.v, ...
                sfile.TestLevel.v, relflag, fnrate);

            k = floor(pulse_begin2(2)/fnrate)+1;
            outdata{mm}.v=zeros(1,npts);
            outdata{mm}.v(km:km+length(levls)-1) = levls;
            outdata{mm}.v(k:k+length(levls2)-1) = levls2;
            outdata{mm}.v = outdata{mm}.v*sfile.Scale.v + sfile.Holding.v; % scale and offset the data
            tbase{mm}.v=fnrate*(0:length(outdata{mm}.v)-1); % time base, in msec for the output
            mm = mm + 1;
        end;
    else
        outdata{mm}.v=zeros(1,npts);
        outdata{mm}.v(km:km+length(levls)-1) = levls;
        outdata{mm}.v = outdata{mm}.v*sfile.Scale.v + sfile.Holding.v; % scale and offset the data
        tbase{mm}.v=fnrate*(0:length(outdata{mm}.v)-1); % time base, in msec for the output
        mm = mm + 1;
    end
    
end; % done with generating the pulse train waveform set

%check for superposition, and do it if necessary
if(~isempty(sfile.Superimpose.v))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'superimpose');
    if(err)
        return;
    end;
end;
% and the second channel information
if(~isempty(unblank(sfile.Addchannel.v)))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'addchannel');
    if(err)
        return;
    end;
end;

if(plotflag == 1)
    teststimplot(tbase, outdata, 0);
end;

err = 0; % only clear error flag if we make it all the way through.

return
end


function [levs] = pulseTrainGenerate(NP, IPI, Duration, Level, relflag, fnrate)
% make a pulse train, which can consist of n pulses with a given interpulse
% interval, with the pulse parameters of duration and level
% the returned "levs" is an array at fnrate of the waveform
levs = [];
j1 = 1;
ipispace = floor(IPI/fnrate);
lev = pulseGenerate(Duration, Level, relflag, fnrate);
llev = length(lev);
jipi = ipispace - llev;
zsp = zeros(jipi, 1);
for p = 1:NP
    levs(j1:j1+llev-1) = lev; % add the pulse
    if p < NP
        levs(j1+llev:j1+llev+jipi-1) = zsp;
        j1 = j1 + llev + jipi;
    end;
end;
levs(end+1) = 0.;% always make sure we have terminated the array...
end


function [lev] = pulseGenerate(Duration, Level, relflag, fnrate)
% make a single "pulse", which can consist of multiple levels with different durations
j1 = 1;
for p = 1:length(Duration) % each pulse consists of a series of steps, so create steps
    j2 = floor(Duration(p)/fnrate); % Number of points in the duration step dur in msec; convert rate to msec too
    if(relflag && p > 1) % check relative
        lev(j1:j1+j2-1)  = Level(1)*Level(p); % value is constant for that time
    else
        lev(j1:j1+j2-1) = Level(p);
    end;
    j1 = j2 + 1;
end;
lev(end+1) = 0.;
return
end

        