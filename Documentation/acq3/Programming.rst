===================
Programming Notes
===================

-------------------
Extending commands
-------------------

As mentioned above, adding new commands to the program is fairly
simple. A command is equivalent to an m-file function that is located
in the source directory, i.e., every m-file in that directory is a
command. Functions that need to be hidden should reside either in the
utility or private directories beneath the source directory. The
m-files in the source directory are registered when the program
starts. To register new commands, use the gather menu item under the
File menu. Commands are interpreted as the minimum unique letter
combination that will specify an m-file. For example, the command l is
not unique, since there are several commands that begin with the
letter l. However, lc will list the configuration file structure to
the MATLAB window (used for debugging purposes).

Command functions may accept parameters on the input line, but each
function must parse and check these parameters on its own. Command
functions should return error messages to the message window using the
QueMessage function, to indicate their status or guide the user.
Command functions may access the data structures STIM, DFILE, and
CONFIG by declaring them to be global variables. Any changes to these
structures will be seen throughout the program, so this should be done
carefully.

--------------------------
Adding Stimulus Protocols
--------------------------

Adding a new stimulus pattern (waveform) requires changes to 3 parts
of the program. First, the routine new.m must be modified to generate
the fields and tags for the new parameters needed. A look at new.m
will make it very clear how this should be done, and how easy it is.
Second, a method routine must be written to generate the stimulus
waveforms. Examples of existing method routines are steps.m, pulses.m,
ramp.m, alpha.m and noise.m; it is recommended that you start by
copying one of these (``noise.m`` and ``steps.m`` are presently the most
recent and probably most cleanly coded stimulus methods). Some support
routines are also available (see ``noise.m`` for how these are used); I
expect to provide a small package of these in the future to simplify
the process. Writing the method itself is usually the most difficult
part of the coding process, as it must handle the sequencing of
stimulus parameters and generate appropriate arrays for output. The
output arrays are held in the form of a cell array, so that each
different stimulus in the output may have a different length or time
base. Note that the command ``pv`` (preview) will generate the stimulus
waveforms by calling the method routine. Third, the name of the
routine must also be registered with the ``chkfile`` routine (found in the
private directory), under STIM, in order to allow the program to
verify the correctness of the structure later on.

Note that stimulus generating protocols can call other protocols to
either generate a second channel or to superimpose two different
classes of waveforms generated by different methods on one channel.
This is handled by the functions ``combine.m`` and ``superimpose.m``. Examples
of their use may be found in each of the existing stimulus method
routines; it usually will suffice to copy the code from those routines
into your new routine. Please send any new routines you develop to me
at the e-mail address above, so I can incorporate them into the base
code structure.

Although the stimulus protocols and their parameters are largely self-
explanatory, a short text on how the parameters control the stimulus
can be helpful (I haven't written such notes yet for the 5 implemented
so far). However, by using the ``pv`` command, it should soon become clear
how the parameters control the generated waveform.


